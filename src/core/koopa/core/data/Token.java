package koopa.core.data;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import koopa.core.targets.HoldingTarget;

/**
 * This is the main data item generated by Koopa. They represent pieces of text,
 * and can carry some metadata in the form of tags.
 * <p>
 * Tags themselves can be anything; though we recommend using enums.
 * <p>
 * <b>Trying to keep this class immutable.</b>
 */
public class Token implements Data {

	private final String text;

	/**
	 * Which {@linkplain Range}s make up this token ?
	 * <p>
	 * <b>Unmodifiable, and always based on a copy of any provided list of
	 * ranges !</b>
	 */
	private final List<Range> ranges;

	/**
	 * Which tags does this token carry ?
	 * <p>
	 * <b>Unmodifiable !</b>
	 */
	private final Set<Object> tags;

	private final Replaced replaced;

	/**
	 * Was this token skipped during the parse, or not ?
	 * <p>
	 * <b>This is a mutable field in an immutable class.</b> Which, of course,
	 * is not what you want. But I made this field mutable for performance
	 * reasons. The preferred way was to add this info as another tag, but this
	 * was one piece of information which was added and retracted so often that
	 * it imposed too much of a performance penalty on the runtime (adding about
	 * 30% of time to parsing the testsuite).
	 * <p>
	 * Alternate solutions considered:
	 * <ul>
	 * <li>Markers, such as for water. But there would be way too many of these
	 * as well.</li>
	 * <li>Asking the grammar. But that only tells you whether a token can be
	 * skipped, not whether it actually was in the end. Removing the ambiguity
	 * is not an option for Cobol.</li>
	 * <li>Counting schemes, or separate bookkeeping, in
	 * {@linkplain HoldingTarget}. Felt too complex and cumbersome.</li>
	 * </ul>
	 */
	private boolean skipped = false;

	/**
	 * Creates a new token from the given text, boundaries and tags.
	 * <p>
	 * Start and end positions should belong to the same resource. I.e.
	 * <code>start.getResourceName()</code> and
	 * <code>(end.getResourceName())</code> are both null, or are equal.
	 */
	public Token(String text, Position start, Position end, Object... tags) {
		assert (start != null);
		assert (end != null);
		assert (start.getResourceName() == null && end.getResourceName() == null
				|| start.getResourceName() != null && start.getResourceName()
						.equals(end.getResourceName()));

		this.text = text;

		final List<Range> ranges = new ArrayList<>(1);
		ranges.add(new Range(start, end));

		this.ranges = Collections.unmodifiableList(ranges);
		this.tags = Collections
				.unmodifiableSet(new HashSet<>(Arrays.asList(tags)));

		this.replaced = null;
	}

	/**
	 * <b>NOTE</b> This is package scoped on purpose. Intended for use by
	 * {@linkplain Tokens} only.
	 */
	Token(String text, List<Range> ranges, Set<Object> tags,
			Replaced replacing) {
		assert (ranges != null);
		assert (ranges.size() > 0);

		this.text = text;

		final List<Range> rangesCopy = new ArrayList<>();
		rangesCopy.addAll(ranges);

		this.ranges = Collections.unmodifiableList(rangesCopy);
		this.tags = Collections.unmodifiableSet(tags);

		this.replaced = replacing;
	}

	/**
	 * Creates a new token which is equivalent to the composition of the given
	 * ones, except for their tags.
	 * <p>
	 * <b>The tags of the original tokens are not aggregated.</b> Instead you
	 * can specify whatever tags the new token should have as extra parameters.
	 * <p>
	 * The {@linkplain Range}s of the original tokens, however, do get
	 * aggregated into the new one.
	 * <p>
	 * The new token will not be seen as replacing some other token, despite
	 * what any of the given tokens may say.
	 * <p>
	 * <b>NOTE</b> This is package scoped on purpose. Please use the
	 * {@linkplain Tokens#join(List, Object...)} method instead.
	 */
	Token(List<Token> tokens, Object... tags) {
		StringBuffer buffer = new StringBuffer();

		for (Token token : tokens)
			buffer.append(token.getText());

		this.text = buffer.toString();

		final List<Range> ranges = new ArrayList<>();
		for (Token token : tokens)
			ranges.addAll(token.ranges);

		assert (ranges.size() > 0);

		this.ranges = Collections.unmodifiableList(ranges);
		this.tags = Collections
				.unmodifiableSet(new HashSet<>(Arrays.asList(tags)));

		this.replaced = null;
	}

	/**
	 * Create a copy of one token, and register the copy as being a replacement
	 * for another one.
	 */
	private Token(Token token, Replaced replacing) {
		assert (token != null);
		assert (replacing != null);

		this.text = token.text;
		this.ranges = token.ranges;
		this.tags = token.tags;
		this.replaced = replacing;
	}

	public String getText() {
		return this.text;
	}

	public char charAt(int index) {
		return text.charAt(index);
	}

	public int getLength() {
		return text.length();
	}

	public Position getStart() {
		return ranges.get(0).getStart();
	}

	public Position getEnd() {
		return ranges.get(ranges.size() - 1).getEnd();
	}

	public Set<Object> getTags() {
		return tags;
	}

	public boolean hasTag(Object tag) {
		return tags.contains(tag);
	}

	/**
	 * Whether or not this token has <b>all</b> given tags.
	 */
	public boolean hasTags(Object... tags) {
		for (Object tag : tags)
			if (!hasTag(tag))
				return false;

		return true;
	}

	/**
	 * Whether or not this token has <b>any</b> of the given tags.
	 */
	public boolean hasAnyTag(Object... tags) {
		for (Object tag : tags)
			if (hasTag(tag))
				return true;

		return false;
	}

	public int tagCount() {
		return tags.size();
	}

	public List<Range> getRanges() {
		return ranges;
	}

	/**
	 * Creates a new token which is a copy of this one, with the addition of the
	 * given tags. If there are no tags given, or they are all already there,
	 * returns <code>this</code> instead.
	 */
	public Token withTags(Object... additionalTags) {
		if (additionalTags.length == 0)
			return this;

		if (hasTags(additionalTags))
			return this;

		Set<Object> newTags = new HashSet<>(tags);
		newTags.addAll(Arrays.asList(additionalTags));
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a new token which is a copy of this one, with the exception of
	 * the given tags. If there are no tags given, or none of them are found
	 * here, returns <code>this</code> instead.
	 */
	public Token withoutTags(Object... theseTags) {
		if (theseTags.length == 0)
			return this;

		if (!hasAnyTag(theseTags))
			return this;

		Set<Object> newTags = new HashSet<>(tags);
		newTags.removeAll(Arrays.asList(theseTags));
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a new token which is a copy of this one, minus one tag (if
	 * present), and with the addition of the other.
	 */
	public Token replacingTag(Object oldTag, Object newTag) {
		Set<Object> newTags = new HashSet<>(tags);
		newTags.remove(oldTag);
		newTags.add(newTag);
		return new Token(text, ranges, newTags, replaced);
	}

	/**
	 * Creates a copy of this token, while linking it to another one by saying
	 * that this token replaces it, either completely or in part.
	 */
	public Token asReplacing(Replaced replacing) {
		if (replacing == null)
			return this;
		else
			return new Token(this, replacing);
	}

	public Replaced getReplaced() {
		return replaced;
	}

	public boolean isReplacement() {
		return replaced != null;
	}

	@Override
	public String toString() {
		String s = null;
		if (replaced == null)
			s = "[" + getStart() + "|" + text + "|" + getEnd() + "]";
		else
			s = "{" + getStart() + "|" + text + "|" + getEnd() + "}";

		if (!tags.isEmpty())
			for (Object tag : tags)
				s += " @" + tag;

		return s;
	}

	public boolean isSkipped() {
		return skipped;
	}

	// TODO Move to Data ?
	public void setSkipped(boolean skipped) {
		this.skipped = skipped;
	}

	// ========================================================================

	private static int hashCounter = 0;
	private final int HASHCODE = hashCounter++;

	/**
	 * For {@linkplain Token} instances, equality boils down to object identity.
	 */
	@Override
	public boolean equals(Object obj) {
		return this == obj;
	}

	/**
	 * Hashcodes for {@linkplain Token} objects are nothing more than a
	 * sequentially generated identifier.
	 */
	@Override
	public int hashCode() {
		return HASHCODE;
	}
}
